## 参考文章
https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/

每个线程都有自己的事件循环

微任务通常安排在当前执行的脚本之后应该立即发生的事情，
例如对一批动作做出反应，或者在不承担全新任务的情况下进行异步操作。只要没有其他 JavaScript 在中间执行，微任务队列就会在回调之后处理，并且在每个任务结束时处理。在微任务期间排队的任何其他微任务都将添加到队列的末尾并进行处理。微任务包括突变观察者回调，如上例所示，承诺回调。

一旦 Promise 完成，或者如果它已经完成，它会为它的反动回调排队一个微任务。这确保了 Promise 回调是异步的，即使 Promise 已经完成。因此，针对已确定的承诺调用 .then(yey, nay) 会立即将微任务排队。这就是为什么在脚本结束后记录 promise1 和 promise2 的原因，因为当前运行的脚本必须在处理微任务之前完成。 promise1 和 promise2 在 setTimeout 之前记录，
因为微任务总是在下一个任务之前发生。


如果脚本设置对象堆栈现在为空，则执行微任务检查点

— HTML：回调步骤 3 后的清理



--Level 1 boss's angry older brother

以前，这意味着微任务在侦听器回调之间运行，但 .click() 会导致事件同步调度，因此调用 .click() 的脚本仍在回调之间的堆栈中。 上述规则确保微任务不会中断正在执行的 JavaScript。 这意味着我们不在侦听器回调之间处理微任务队列，它们在两个侦听器之后处理。





