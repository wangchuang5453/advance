# 垃圾回收

js自动内存管理实现 内存分配 和 闲置资源回收

基本思路：确定哪个变量不再使用，然后释放它占用的内存

这个过程是周期性的，即垃圾回收每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行

垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。

浏览器发展历史上用到过2种主要的标记策略：标记清理和引用计数

## 标记清理

垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记的方法有很多种）。
然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。
在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。
然后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

缺点：（来自网络）
上图我们可以看到，红色区域是一个根对象，就是一个全局变量，会被标记；而蓝色区域就是没有被标记的对象，会被回收机制回收。这时就会出现一个问题，表面上蓝色区域被回收了三个空间，但是这三个空间是不连续的，当我们有一个需要三个空间的对象，那么我们刚刚被回收的空间是不能被分配的，这就是“空间碎片化”。

## 引用计数
思路是对每个值都**记录它被引用**的次数
引用数为0时，就说明没办法再访问到这个值了，可以安全的回收其内存了。
但是会遇到很严重的问题：循环引用  

所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。意味着他们的引用数都是2，函数调用结束后都不会被清理掉。


## 性能
在介绍垃圾回收算法之前，我们先了解一下「全停顿」。垃圾回收算法在执行前，需要将应用逻辑暂停，执行完垃圾回收后再执行应用逻辑，这种行为称为 「全停顿」（Stop The World）。例如，如果一次GC需要50ms，应用逻辑就会暂停50ms。
--博客

执行垃圾回收时，程序中的其他各种逻辑都要进入暂停等待阶段，直到垃圾回收结束后才会再次重新执行JS逻辑。因此，由于JS的单线程机制，垃圾回收的过程阻碍了主线程逻辑的执行。

--博客

尤其在内存有限的移动设备上，垃圾回收有可能明显拖慢渲染的速度和帧速率。
开发者并不知道什么时候会开始收集垃圾，因此最好的办法是做到无论什么时候开始，要能让它尽快结束工作。

何时运行？
现代垃圾回收程序会给予对js运行环境的探测来决定合适开始运行。
探测机制因引擎而异，但基本上按照已分配对象的大小和数量来判断的。
比如V8团队2016年一篇博文说法，在一次完整的垃圾回收之后，v8的堆增长策略会根据活跃对象的数量外加一些余量来确定何时再次垃圾回收。

IE曾经策略是根据分配数，比如分配了256个变量，406个数组/对象字面量和数组槽位，或者64KB字符串，只要满足其中一个条件，垃圾回收运行。很可能整个生命周期内始终需要这么多变量，结果会导致垃圾回收程序过于频繁的运行。IE7，则调优为动态分配变量、字面量或者数组槽位等会触发垃圾回收的阀值。IE7起始阀值与IE6相同。如果垃圾回收的内存不到已分配的15%，这些变量、字面量或者数组槽位的阀值就会翻倍。如果有一次回收的内存达到已分配的85%，则阀值重置为默认值。极大提升了性能。

## 内存管理

如果数据不再必要，那么设置为null，从而释放引用，叫做解除引用。这个建议最适合全局变量和全局对象的属性。
解除引用关键在于确保相关的值已经不再上下文里了，因此它在下次垃圾回收时会被回收。

1、通过const和let声明提升性能
有助于改进垃圾回收
const let 以块为作用域而非函数，相比于var能够更早的让垃圾回收程序介入，尽早回收应该回收的内存。
在**块级作用域比函数作用域更早终止情况下**就有可能发生。

2、隐藏类和删除操作


3、内存泄漏
意外声明全局变量是最常见也是最容易修复的内存泄漏问题

闭包容易不知不觉间造成内存泄漏
  定时器的回调通过闭包引用外部变量，导致内存泄漏

4、静态分配与对象池
能够合理使用分配的内存，同时避免多余的垃圾回收，就可以保住因释放内存而损失的性能

浏览器决定运行垃圾回收程序的一个标准就是对象更迭的速度。
很多对象被初始化然后又一下子超出了作用域，那么浏览器就会采取更激进的方式调度垃圾回收程序运行。

静态分配数组大小
静态分配是优化的一种极端形式。大多数情况都属于过早优化，可以不必考虑。










