# Number类型

## 十进制 => x进制

### 整数部分：
你以十进制的数除以你所要转换的进制数,把每次除得的余数记在旁边,所得的商数继续除以进制数,直到余数为0时止.例如你

要把100转换成八进制: 
100/8=12...(余数为4); 
12/8=1.....(余数为4); 
1/8=0......(余数为1); 
然后把相应的余数从低向高顺着写出来,如上的为144,此即为100的八进制表示形式. 

十进制转换为十六进制与二进制与前面的转化为八进制相同,如100转换为十六进制: 
100/16=6....(余数为4); 
6/16=0......(余数为6); 
同理则以十六进制表示的100形式为64; 

100转换为二进制: 除2取余
100/2=50....(余数为0); 
50/2=25.....(余数为0); 
25/2=12.....(余数为1); 
12/2=6......(余数为0); 
6/2=3.......(余数为0); 
3/2=1.......(余数为1); 
1/2=0.......(余数为1); 
所以100的二进制表示形式为1100100;（从下往上）

要换回来就反着算!

### 小数：
十进制
0.625	用10进制表示为0.625 => 6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005

0.625 用二进制表示为0.101 => 1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8 => 0.625


十进制小数转二进制方法：乘2取整
0.5 =>
0.5 * 2 = 1 # 1
0 * 2 = 0 # 0
.....

0.5的二进制格式是：0.1  1 * 2^-1 = 1/2 => 0.5(10进制)


0.1 =>

0.1 * 2 = 0.2 # 0
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0

.....

0.1的二进制格式是：0.0001100011....。二进制无限循环小数

============================================================

# 为什么0.1+0.2不等于0.3 ？

0.1 + 0.2 > 0.3 // true
0.1 * 0.1 = 0.010000000000000002

从上面可以看出，0.1的二进制格式是：0.0001100011....。这是一个**二进制无限循环小数**，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？

答案是：在某个精度点直接舍弃。当然，代价就是，0.1在计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1。当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于0.3 的原因。

# 0.1 + 0.1 为什么等于0.2 ？
两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。

**另外要注意**
二进制能精确地表示位数有限且分母是2的倍数的小数，比如0.5，0.5在计算机内部就没有舍入误差。
所以0.5 + 0.5 === 1


============================================================

# NaN (not a number)

NaN == NaN // false

'a'/'b'  // NaN

## isNaN 任何不能转换为数值的都会导致返回true
isNAN(NAN)  // true
isNAN(10)  // false
isNAN('10') // false  
isNAN('blue') // true
isNAN(true) // false      **true可以转换为1**

============================================================

# 类型转换 Number()
Number()  // 0 

## boolean => number
Number(true) // 1  **注意**
Number(false) // 0

## string => number

Number('11') // 11
Number('0011') // 11 去0
Number('    001') // 1 去空格
Number('    a002') // NaN 去空格后第一个开始看 含有非数字字符就不行了 **parseInt却不同**

浮点格式
Number('1.1') // 1.1
Number('01.1') // 1.1 去0

Number('abc') // NaN
Number('') // 0

x进制 => 10进制
Number('0xf') // 15

## null => number
Number(null) // 0

## undefined => number
Number(undefined) // NaN


============================================================

# parseInt

parseInt(22.9) // 22

parseInt('') // NaN


从去空格后第一个字符开始判断。
如果是数值字符或者+—号，则继续依次监测每个字符，直到字符串末尾或者碰到非数值字符；
如果不是数值字符或者+—号，则直接返回NaN。
parseInt('  99 blue')  // 99  **Number(  99 blue) 直接NaN**
parseInt('  a99blue') // NaN

默认按照10进制处理
parseInt('0xA') // 10 解释为16进制整数
parseInt('0xf') // 15 解释为16进制整数
parseInt('22.5') // 22
parseInt('70') // 70

parseInt('AF', 16) // 175 处理16进制到10进制
parseInt('AF') // NaN  默认解释为10进制

parseInt('10', 2) // 2
parseInt('10', 8) // 8
parseInt('10', 10) // 10
parseInt('10', 16) // 16

parseInt('3.125e7') // 3

# parseFloat

和parseInt类似，只是处理到浮点数

parseFloat('1234blue') // 1234
parseFloat('0xA') // 0
parseFloat('22.5') // 22.5
parseFloat('22.34.5') // 22.34
parseFloat('0908.5') //908.5

parseFloat('3.125e7') // 31250000


















