


# Number类型

## 十进制 => x进制

### 整数部分：
你以十进制的数除以你所要转换的进制数,把每次除得的余数记在旁边,所得的商数继续除以进制数,直到余数为0时止.例如你

要把100转换成八进制: 
100/8=12...(余数为4); 
12/8=1.....(余数为4); 
1/8=0......(余数为1); 
然后把相应的余数从低向高顺着写出来,如上的为144,此即为100的八进制表示形式. 

十进制转换为十六进制与二进制与前面的转化为八进制相同,如100转换为十六进制: 
100/16=6....(余数为4); 
6/16=0......(余数为6); 
同理则以十六进制表示的100形式为64; 

100转换为二进制: 除2取余
100/2=50....(余数为0); 
50/2=25.....(余数为0); 
25/2=12.....(余数为1); 
12/2=6......(余数为0); 
6/2=3.......(余数为0); 
3/2=1.......(余数为1); 
1/2=0.......(余数为1); 
所以100的二进制表示形式为1100100;（从下往上）

要换回来就反着算!

### 小数：
十进制
0.625	用10进制表示为0.625 => 6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005

0.625 用二进制表示为0.101 => 1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8 => 0.625


十进制小数转二进制方法：乘2取整
0.5 =>
0.5 * 2 = 1 # 1
0 * 2 = 0 # 0
.....

0.5的二进制格式是：0.1  1 * 2^-1 = 1/2 => 0.5(10进制)


0.1 =>

0.1 * 2 = 0.2 # 0
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0

.....

0.1的二进制格式是：0.0001100011....。二进制无限循环小数



# 为什么0.1+0.2不等于0.3 ？

0.1 + 0.2 > 0.3 // true
0.1 * 0.1 = 0.010000000000000002

从上面可以看出，0.1的二进制格式是：0.0001100011....。这是一个**二进制无限循环小数**，但计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？

答案是：在某个精度点直接舍弃。当然，代价就是，0.1在计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1。当代码被编译或解释后，0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没开始，一个很小的舍入错误就已经产生了。这也就是 0.1 + 0.2 不等于0.3 的原因。

# 0.1 + 0.1 为什么等于0.2 ？
两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。

**另外要注意**
二进制能精确地表示位数有限且分母是2的倍数的小数，比如0.5，0.5在计算机内部就没有舍入误差。
所以0.5 + 0.5 === 1



