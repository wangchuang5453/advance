# 2.3 HTTP是不保存状态的协议
HTTP协议自身不对请求和响应之间的通信状态进行保存，不做持久化处理

# 2.7 持久化连接
http初始版本，每进行一次HTTP通信就要断开一次TCP连接

http1.1
## keep-alive持久连接
只要任意一端没有明确提出断开连接，则保持TCP连接状态
好处：
减少了TCP连接重复建立和断开造成的额外开销，节省了时间

何时会断开？由谁发起？

## 管线化
可以同时并行发送多个请求，而不需要一个接一个地等待响应

通常，HTTP请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。
HTTP/1.1允许多个HTTP请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。

如果一个请求被取消了，会发生什么？
如果一请求被取消了，是不是意味着整个管道都被取消了呢？或者，是不是意味着这个被取消请求的响应应该被简单的丢弃，以便这个管道中的其他请求不会被强制重发？
这个答案依赖于很多因素，包括，这个被取消请求的响应还有多少没有被收到。
最原始的办法可能是简单的取消管道，然后重发所有的请求。仅仅当请求是幂等的时候才可以。
这样原始的方法也可以产生好的影响，因为正在管道中被发送的请求可能属于同一个正在被取消的页面载入组。

如果连接失败会发生什么？
如果连接失败了或服务器在下载一个管道中的响应时中断了，浏览器必须有能力重新开始发送被丢失的请求。这种情况可以等同于上面讨论的被取消的例子。

补充
HTTP/方法的幂等性：是指一次和多次请求某一个资源应该具有同样的副作用。幂等性的请求，实际上就是多次操作都不会改变结果的请求，比如GET，我可以多次从同一个地方获取资源，但是对于资源本身来说并不会发生什么变化，我GET10次和GET100次，资源都没有发生任何变化。而Post则不同了，我提交表单10次，和100次，造成的结果是不同的，至少数据库里新增的数据有不同。

**其实HTTP管线化就是将客户端的FIFO队列移到了服务端。**
在客户端可以依次发送所有要发送的请求（当然这些请求是在同一个域下的），一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出。
在服务器端维持的FIFO队列，这个队列是按照资源的重要程度排列的。比如HTML比CSS要先返回，JS，CSS比图片先返回。
在服务器端会有一个缓冲区，来存放那些已经被处理好了但是还没轮到被发送的响应。
比如服务器先后收到了A,B两个请求，A资源比B资源优先级要高，处理A需要10ms，处理B需要1ms，假设服务器可以并行处理请求，那么B的响应肯定是最先处理好了的，但是B响应不能先发出去，必须待在缓冲区里，等待A响应处理好了之后，先把A的响应发出去，B的响应才能够被发出去。因为服务端必须要遵循FIFO这个原则。




## 使用Cookie的状态管理
服务器在响应报文中写入Set-Cookie

请求报文中携带Cookie










