# 2.3 HTTP是不保存状态的协议
HTTP协议自身不对请求和响应之间的通信状态进行保存，不做持久化处理

# 2.7 持久化连接
http初始版本，每进行一次HTTP通信就要断开一次TCP连接

http1.1
## keep-alive持久连接
只要任意一端没有明确提出断开连接，则保持TCP连接状态

### 运行机制解析
非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，**完成之后立即断开连接**（HTTP协议为无连接的协议）；
当使用Keep-Alive模式（又称持久连接、**连接重用**）时，Keep-Alive功能使客户端到服务器端的连接持续有效，
**当出现对服务器的后继请求时**，Keep-Alive功能避免了建立或者重新建立连接。
客户端和服务器之间的HTTP连接就会被保持，不会断开（**超过Keep-Alive规定的时间，意外断电等情况**除外），
**当客户端发送另外一个请求时，就使用这条已经建立的连接**。

### Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？
对于非持续连接，浏览器可以通过连接是否关闭来界定请求或响应实体的边界；
而对于持续连接，这种方法显然不奏效。有时，尽管我已经发送完所有数据，但浏览器并不知道这一点，它无法得知这个打开的连接上是否还会有新数据进来，只能傻傻地等了。
（1）使用消息首部字段Conent-Length
Conent-Length表示实体内容长度，当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，
然后通过Content-length消息首部字段告诉客户端 需要接收多少数据。
（2）使用消息首部字段Transfer-Encoding
如果是动态页面等时，服务器是不可能预先知道内容大小。
因为对于动态生成的内容来说，在内容创建完之前，长度是不可知的。这时候要想准确获取长度，只能开一个足够大的 buffer，等内容全部生成好再计算。
但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。所以不可能这么做（下面说的边拿边就发了）。Conent-Length就失效了。
这时就可以使用Transfer-Encoding：chunk模式：**服务器就需要使用Transfer-Encoding: chunked**这样的方式来代替Content-Length。
即如果要**一边产生数据，一边发给客户端**。
=> 分块编码（Transfer-Encoding: chunked）
Transfer-Encoding，是一个 HTTP 头部字段（响应头域），字面意思是「传输编码」。
最新的 HTTP 规范里，只定义了一种编码传输：分块编码(chunked)。
分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由网页服务器发送给客户端的数据可以分成多个部分。
分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。
数据分解成一系列数据块，并以一个或多个块发送，这样服务器可以发送数据而不需要预先知道发送内容的总大小。
具体方法
在头部加入 Transfer-Encoding: chunked 之后，就代表这个报文采用了分块编码。
这时，报文中的实体需要改为用一系列分块来传输。
每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的 CRLF(\r\n)，也不包括分块数据结尾的 CRLF。
**最后一个分块长度值必须为 0，对应的分块数据没有内容，表示实体结束。**
Content-Encoding 和 Transfer-Encoding 二者经常会结合来用，其实就是针对 Transfer-Encoding 的分块再进行 Content-Encoding压缩。





### 好处：
减少了TCP连接重复建立和断开造成的额外开销，节省了时间

### 何时会断开？由谁发起？
超时断开

## 管线化
可以同时并行发送多个请求，而不需要一个接一个地等待响应

通常，HTTP请求总是顺序发送的，下一个请求只有在当前请求的响应被完全接受的时候才会被发送。由于网络延迟和带宽的限制，这样会导致在服务器发送下一个响应的时候中间有很大的延迟。
HTTP/1.1允许多个HTTP请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。

如果一个请求被取消了，会发生什么？
如果一请求被取消了，是不是意味着整个管道都被取消了呢？或者，是不是意味着这个被取消请求的响应应该被简单的丢弃，以便这个管道中的其他请求不会被强制重发？
这个答案依赖于很多因素，包括，这个被取消请求的响应还有多少没有被收到。
最原始的办法可能是简单的取消管道，然后重发所有的请求。仅仅当请求是幂等的时候才可以。
这样原始的方法也可以产生好的影响，因为正在管道中被发送的请求可能属于同一个正在被取消的页面载入组。

如果连接失败会发生什么？
如果连接失败了或服务器在下载一个管道中的响应时中断了，浏览器必须有能力重新开始发送被丢失的请求。这种情况可以等同于上面讨论的被取消的例子。

补充
HTTP/方法的幂等性：是指一次和多次请求某一个资源应该具有同样的副作用。幂等性的请求，实际上就是多次操作都不会改变结果的请求，比如GET，我可以多次从同一个地方获取资源，但是对于资源本身来说并不会发生什么变化，我GET10次和GET100次，资源都没有发生任何变化。而Post则不同了，我提交表单10次，和100次，造成的结果是不同的，至少数据库里新增的数据有不同。

**其实HTTP管线化就是将客户端的FIFO队列移到了服务端。**
在客户端可以依次发送所有要发送的请求（当然这些请求是在同一个域下的），一个请求发送完之后，不必等待这个请求的响应被接受到，下一个请求就可以被再次发出。
在服务器端维持的FIFO队列，这个队列是按照资源的重要程度排列的。比如HTML比CSS要先返回，JS，CSS比图片先返回。
在服务器端会有一个缓冲区，来存放那些已经被处理好了但是还没轮到被发送的响应。
比如服务器先后收到了A,B两个请求，A资源比B资源优先级要高，处理A需要10ms，处理B需要1ms，假设服务器可以并行处理请求，那么B的响应肯定是最先处理好了的，但是B响应不能先发出去，必须待在缓冲区里，等待A响应处理好了之后，先把A的响应发出去，B的响应才能够被发出去。因为服务端必须要遵循FIFO这个原则。




## 使用Cookie的状态管理
服务器在响应报文中写入Set-Cookie

请求报文中携带Cookie










