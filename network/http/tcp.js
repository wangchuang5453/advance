/**
 * TCP三次握手 
 * 参考文章：
 * https://www.eet-china.com/mp/a44399.html
 * https://blog.csdn.net/webnumen/article/details/1541330
 * https://juejin.cn/post/6983639186146328607#heading-1
 * https://segmentfault.com/a/1190000039165592 ！！最好
 */


/**
 * 企业微信打电话信号不好
 * 1：喂，听得到吗
 * 2：听到了，你听到吗？
 * 1：听到了听到了
 * 121212blabla...
 * 
 * （可以先简单概述 TCP 过程，然后三次握手具体描述时，需要说明状态的基本转换）
 */


/**
 * 本质：
 * 通过 彼此都发出了自己的消息，又都收到了对方的消息
 * 判断 双方的接收和发送能力是否正常
 * 
 * 三次握手的作用？
 * 进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常，
 * 指定自己的 初始化序列号(Init Sequense Number, ISN) 为后面的可靠性传输做准备。
 */



/**
 * （三次握手过程可见tcp3.png）
 * 第一次握手：（第一次握手(SYN=1, seq=x)，发送完毕后，客户端进入 SYN_SEND 状态）
 * 客户端向服务端发送一个 SYN 报文（SYN = 1），并指明客户端的初始化序列号 ISN(x)，
 * 即图中的 seq = x，表示本报文段所发送的数据的第一个字节的序号。此时客户端处于 SYN_SEND 状态。
 * 
 * 第二次握手：（第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端进入 SYN_RCVD 状态）
 * 服务器收到客户端的 SYN 报文之后，会发送 SYN 报文作为应答（SYN = 1，ACK = 1 确认连接的意思），并且指定自己的初始化序列号 ISN(y)，即图中的 seq = y。
 * 同时会把客户端的 ISN + 1 作为确认号 ack 的值，表示已经收到了客户端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 x + 1，
 * 此时服务器处于 SYN_REVD 的状态。
 * 
 * 第三次握手：（第三次握手(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时,也进入 ESTABLISHED 状态，TCP 握手，即可以开始数据传输）
 * 客户端收到服务器端响应的 SYN 报文之后，会发送一个 ACK 报文，也是一样把服务器的 ISN + 1 作为 ack 的值，
 * 表示已经收到了服务端发来的的 SYN 报文，希望收到的下一个数据的第一个字节的序号是 y + 1，并指明此时客户端的序列号 seq = x + 1（初始为 seq = x，所以第二个报文段要 +1），
 * 此时客户端处于 Establised 状态。
 * 
 */


/** 
 * 问题：为什么 TCP 采用三次握手，二次握手可以吗？
 * 
 * 那么假设二次握手后就建立连接，看看会出现什么问题
 * 服务端无法判断客户端接收消息的能力是否正常，这就会出现两种情况：
 * 1、客户端收到了消息，只是没有再次通知服务端，可以通信，但是不够可靠不能满足复杂场景的应用。
 * 比如无法阻止重复历史连接的初始化，客户端如果因为某种原因，发送了两个SYN包，如果是三次握手，
 * 第二次握手返回SYN+ACK包时发现是旧的报文，那么向服务器发送RST报文，知道正确的报文到达服务器才建立连接。
 *
 * ？？？我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDoS 攻击的。
 * 
 * 2、客户端没有收到消息
 * ①客户端不具备接收消息的能力
 * 如果建立了连接，这个连接是无法正常使用的，浪费资源
 * ②客户端具备接收能力，但是没有接收到，那就拿不到服务器发送的初始序列号，
 * 建立连接之后，连接传递信息的可靠性无法保证
 * => 引申
 * 初始序列号（ISN initial sequence number）是什么，如何使用的？作用是什么？
 * TCP发送方发送的字节数据的原点
 * 三次握手中有一个重要的功能就是客户端和服务端交换初始化序列号，以便让对方知道接下来接收到的数据
 * 如何按照序列号顺序进行组装。
 * 
 * 序列号：
 * 本报文段所发送数据的第一个字节的序号
 * 
 * TCP通过数据分段中的序列号来保证所有传输的数据可以按照正常的顺序进行重组，从而保障数据传输的完整。
 * 
 */

/**
 * ISN 是固定不变的吗？
 * ISN初始化序列号如果是固定的，攻击者很容易猜出后续的确认号，为了避免被攻击者发送伪造的数据，ISN是动态生成的。
 * 
 */


/**
 * 三次握手过程中可以携带数据吗?
 * 第一次、第二次握手绝对不可以携带数据，第三次握手的时候，是可以携带数据的。
 * 如果第一次握手可以携带数据的话，那么如果有人要恶意攻击服务器，他只要在第一次
 * 握手的时候携带大量数据，然后疯狂重复发送SYN报文，这会让服务器大量的内存空间
 * 来缓存这些报文。
 * 第三次握手，已经确认服务端的接受发送能力是正常的了，连接也已经建立，可以正常发送数据了。
 * 
 */

/**
 * 半连接队列
 * 服务器第一次收到SYN报文后，处于SYN_RCVD状态，此时还没有完全建立连接，服务器会把这种
 * 状态下的请求连接放在一个队列里，我们把这种队列称之为办半连接队列。
 * 
 * 全连接队列
 * 完成三次握手建立起的连接会被放在一个队列里，这个队列称为全连接队列。
 * 
 */

/**
 * SYN 泛洪攻击 （TCP Flood Attack 或者 半开攻击）
 * 
 * 攻击者通常使用假的ip地址，向服务器上的每个端口重复发送SYN数据包，服务器接收到SYN之后，发送SYN-ACK。
 * 要么恶意客户端不发送预期的ACK，要么ip地址被欺骗一开始就永远不会收到SYN-ACK。
 * 无论哪种方式，受到攻击的服务器都会等待对其SYN-ACK数据包的确认一段时间。
 * 在连接超时之前，不断有SYN数据包到达，有越来越多的连接半开。
 * 最终，随着服务器的连接表被填满，对合法客户端的服务将会被拒绝，服务器甚至可能出现故障或者崩溃。
 * 
 * 本质上，使用 SYN 泛洪 DDoS，攻击者发送 TCP 连接请求的速度比目标机器处理它们的速度快，从而导致网络饱和。
 */

/**
 * 如果第三次握手丢失了，客户端服务端会如何处理？
 * 服务器发送完 SYN-ACK 包，如果未收到客户端响应的确认包，也即第三次握手丢失。
 * 那么服务器就会进行首次重传，若等待一段时间仍未收到客户确认包，就进行第二次重传。
 * 如果重传次数超过系统规定的最大重传次数，则系统将该连接信息从半连接队列中删除。
 * 
 * 注意，每次重传等待的时间不一定相同，一般会是指数增长，例如间隔时间为 1s，2s，4s，8s…
 */



/** 
 * TCP 作为一种可靠传输控制协议，
 * 其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求
 */


/**
 * tcp 四次挥手   终止一个连接需要经过四次挥手（结合图tcp4.png理解并添加细节，下述过于简单）
 * 客户端和服务端均可主动发起挥手动作
 * 
 * 第一次挥手：
 * 客户端发送一个 FIN 报文（请求连接终止：FIN = 1），报文中会指定一个序列号 seq = u。
 * 并停止再发送数据，主动关闭 TCP 连接。此时客户端处于 FIN_WAIT1 状态，等待服务端的确认。
 * 
 * 第二次挥手：
 * 服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序号值 +1 作为 ACK 报文的序列号值，
 * 表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。
 * 此时的 TCP 处于半关闭状态，客户端到服务端的连接释放。
 * 客户端收到服务端的确认后，进入FIN_WAIT2（终止等待 2）状态，等待服务端发出的连接释放报文段。
 * 
 * 第二次挥手之后服务端还可以发送未发送完的数据！！！序列号数值
 * 
 * 第三次挥手：
 * 如果服务端也想断开连接了（没有要向客户端发出的数据），和客户端的第一次挥手一样，发送 FIN 报文，且指定一个序列号。
 * 此时服务端处于 LAST_ACK 的状态，等待客户端的确认。
 * 
 * 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答（ack = w+1），
 * 且把服务端的序列值 +1 作为自己 ACK 报文的序号值（seq=u+1），此时客户端处于 TIME_WAIT （时间等待）状态。
 * 
 * 注意 ！！！这个时候由服务端到客户端的 TCP 连接并未释放掉，
 * 需要经过时间等待计时器设置的时间 2MSL（一个报文的来回时间） 后才会进入 CLOSED 状态
 * （这样做的目的是确保服务端收到自己的 ACK 报文。
 * 如果服务端在规定时间内没有收到客户端发来的 ACK 报文的话，服务端会重新发送 FIN 报文给客户端，
 * 客户端再次收到 FIN 报文之后，就知道之前的 ACK 报文丢失了，然后再次发送 ACK 报文给服务端）。
 * 服务端收到 ACK 报文之后，就关闭连接了，处于 CLOSED 状态。
 * 
 */

/**
 * 为什么要四次挥手？
 * 由于 TCP 的半关闭（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
 * 
 * 任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态（关闭了发送）。
 * 当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
 * 
 * 关键原因就是对方可能还有数据要发送，先半关闭，等待对方确认是否发送完成
 */