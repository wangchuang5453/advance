# 二分搜索树

## 二分搜索树的优势

通常是为了实现查找表（字典）这种结构

key1 value1
key2 value2
key3 value3
key4 value4
key5 value5
key6 value6
key7 value7

大量的这种key value数据对

如果key的值都是整数，而且范围比较小，直接用数组就可以索引到value的值。
但是很多时候不能使用整数来表达key的值，或者比较稀疏使用数组不经济。

字典的key就是一个字符串。

**二分搜索树的优势：**
1、普通数组
查找元素：O(n)
插入元素：O(n) // 要从头到尾扫一遍看是不是已经存在了
删除元素：O(n)

2、顺序数组
查找元素：O(logn) // 可以使用二分查找法1/2不断拆分，是logn
插入元素：O(n)
删除元素：O(n)

3、二分搜索树
查找元素：O(logn)
插入元素：O(logn)
删除元素：O(logn)

可以保证都是logn，很高效
不仅高效，还可以方便的回答很多数据之间的关系问题：min max floor ceil rank select

## 什么是二分搜索树

是一个二叉树
每个节点的键值大于左孩子
每个节点的键值小于右孩子
以左右孩子为根的子树仍然为二分搜索树
不一定是完全二叉树，用数组表示不方便

## 二分搜索树的遍历 O(n)

1、二分搜索树的前中后序遍历（深度优先遍历）

**三个点方式**理解

前序遍历：先访问当前节点，再依次递归访问左右子树

中序遍历：先递归访问左子树，再访问自身，再递归访问右子树
拿到的数据是从小到大 可以应用于排序

后序遍历：先递归访问左右子树，再访问自身节点
应用于释放二叉树过程 先释放子树然后释放自身


2、层序遍历（广度优先遍历）：
使用队列辅助


## 二分搜索树 删除任意一个节点（最难） O(logn)

找右子树的最小值

删除左右都有孩子的节点d
找到s=min(d.right)
s是d的后继
s.right = delmin(d.right)
s.left = d.left
删除d,s是新子树的根

也可以找左子树的最大值


## 二分搜索树的顺序性

minimum maximum

successor  predecessor
找后继和前驱

floor ceil

rank select

...



## 平衡二叉树











