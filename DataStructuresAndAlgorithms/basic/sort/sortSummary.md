# 排序算法总结
名词解释：
排序算法的稳定性stabel
稳定排序：对于相等的元素，在排序后，原来靠前的元素依然靠前。相等元素的相对位置没有发生改变。

这个很有价值，比如学生的成绩排序，一开始是按照名字排序的，如果是稳定的排序，那么按照成绩排序之后，相同成绩的学生排序依然是按照名字的排序进行的。
稳定性和实现相关，如果实现的不好可能变成不稳定的。

可以通过自定义比较函数，让排序算法不存在稳定性的问题。
比如：
```js

function operator() {
  return score != otherStudent.score ?
    score > otherStudent.score : name < otherStudent.score;
}

```
会出现效率上的损耗，但是现代计算机是完全可以承受的。只是在一些对性能非常敏感的情况下，或者说比较函数不太好更改的情况下，无法使用。






## 插入排序
**平均**时间复杂度：O(n^2)
数据如果已经趋近于有序，插入排序就会到O(n)这个级别

原地排序：true

额外空间：O(1)

稳定性：true



## 归并排序
**平均**时间复杂度：O(nlogn)

原地排序：false
必须开辟额外的空间

额外空间：O(n)
递归应该是O(n + logn),但是因为logn比n小，就忽略不计了。

稳定性：true

## 快速排序
**平均**时间复杂度：O(nlogn)
极其特殊的时候会退化到O(n^2)这个级别，使用随机化的方式来处理，使得这个可能性极其低。
总体而言，快排是更加快的排序算法，也就是说对于这3个中O(nlogn)级别的排序算法，常数上有差异。快速排序相对占优，一般都是采用快速排序这种方式。对于大量重复数据这种情况可以使用三路快排这样的方式。

原地排序：true

额外空间：O(logn)
采用递归方式排序，递归过程共有logn这么多层，需要相应的栈空间来保存每一次递归过程中的临时变量，以便递归返回的时候使用。


稳定性：false
随机选择标定点，很有可能就改变了顺序



## 堆排序
**平均**时间复杂度：O(nlogn)

原地排序：true

额外空间：O(1)

稳定性：false
将整个数组组建成堆的过程中，有可能破坏这个先后的顺序。


## 冒泡排序

## 希尔排序
